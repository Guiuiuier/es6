<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<!-- 作用域练习 -->
<!-- <style>
    .item{
      background-color: red;
    }
</style>
   <div class="item">1</div>
   <div class="item">1</div>
   <div class="item">1</div> -->


<!-- 2s后变换div颜色 -->
<!-- <style>
        div{
             width:200px;
             height: 200px;
             background-color: #bfa;
        }
    </style>
    <div id="ad"></div> -->

</html>
<script>
    // es6标准
    // 声明变量 let a;
    // let b, c, d;
    // let e = 100;

    // 变量不能重复声明
    // let a = 1;
    // let a = 1;
    // 块级作用域、全局作用域、函数作用域、eval作用域
    /*   if else while for 如果用let声明的话 也是块级作用域
           {
               let girl='周扬青'；

           }
           console.log(girl);
    */
    // 不存在变量提升 var 可以 let不行
    // var song = "恋爱达人";
    // let song = "恋爱达人";
    // 不影响作用域链条  一样可以通过上下文查找
    /*{
         let school="niu";
         function fn(){
             console.log(school);
         }
         fn();
    }*/

    //块级作用域例题
    //   let items=document.getElementsByClassName("item");
    //     for(let i=0;i<items.length;i++){
    //         items[i].onclick=function(){
    //             //用this
    //         //  this.style.background="pink";
    //          //报错
    //          items[i].style.background="pink";
    //          //但此时如果换成let i 就可以了 因为 let i 块级作用域只在块内有效
    //     }
    // }
    //  //
    // //  {
    // //    let i=0;
    //     // 代码    
    // //  }
    //     //当循环完成后i变成3了
    //     console.log(window.i);

    //声明常量 一定要赋值
    //   const SC="ddd";
    //一般常量使用大写；常量的值一旦确定无法修改
    //常量块级作用域
    //   {
    //    const DD="uzi";
    //   }
    //   console.log(DD); //无法找到因为是块级作用域
    //对于数组和对象的元素修改 不算做对常量的修改 不会报错
    // const TEAM=['uzi','msmd'];
    // TEAM.push("dsd");

    // es6允许按照一定模式从数组和对象中提取值 对变量进行赋值，这被称为解构赋值
    //数组的结构
    //   const F4=['sdds','dsd'];
    //   let [xiao,liu]=F4;  //对应数组上边的每个位置
    //   console.log(xiao);
    //对象的结构
    /*const zhao={
        name:'zhao',
        age:'333',
        xiaopin:function(){
            console.log("d");
        }
       }*/
    //对象的保存方法
    //   let  {name,age,xiaopin}=zhao;
    //   console.log(name);
    // zhao.xiaopin() //如果一直调用很麻烦 一直写zhao
    //改进 这样就不用写zhao.xiaopin了  
    // let {xiaopin}=zhao;
    //   xiaopin();


    //es6中模板字符串
    //声明 
    //  let str="wwosss";
    //  console.log(str,typeof str); //string
    // 内容中可以直接出现换行符
    //   let str='<ul><li>肾疼</li><ul>';  //如果没换行缩进很难受 此处是不能换行的 以前需要引号和加号连接才可以，
    // let str=  `<ul>s
    // <li>肾疼</li><ul>`  ; //  英文状态下的tab 反引号可以换行
    //  console.log(str)

    //变量拼接
    //  let lovse=`sdsd`;
    //  let dd=`sd`;
    //   let out =`${lovse}sdsd`;  //变量拼接固定写法
    //   console.log(out);


    //es允许在大括号里面直接写入变量和函数，作为对象的属性和方法
    //   let name='ddd';
    //    let change=function(){
    //        console.log("sdsd");
    //    } 
    //  const SCHOOL={
    //       name,
    //       change,
    //improve(){
    //  console.log(ddd);
    //}  这个函数节省了:
    //   }
    //   console.log(SCHOOL);


    //箭头函数
    //声明一个函数
    //    let fn=function(){
    //原本写法
    //    }
    //    let fn=(a,b)=>{
    //   return a+b;
    //    }
    //    let result=fn(1,2);
    //    console.log(result);
    //  箭头函数 this是静态的 始终指向函数声明所在作用域下的this值
    // 不指向const
    // function getName(){
    //     console.log(this.name);
    // }
    // let  getName2=()=>{
    //     console.log(this.name);
    // }
    // window.name="dsds去问他dsf";
    //  const school={
    //      name:"dsdfffsds",
    //  }
    //  getName();
    //  getName2();


    //call方法调用
    //   getName.call(school) //指向全局对象 
    //    getName2.call(school); //指向块级作用域。
    // 不能作为构造函数实例化对象
    //  let Person=(name,age)=>{
    //   this.name=name;
    //   this.age=age;

    //  }
    //  let me = new Person('xiao',30); //箭头函数不能作为实例化独享
    //   console.log(me);
    //箭头函数不能使用arguments变量
    // let fn=()=>{
    // console.log(arguments);
    // }
    // fn(1,23,3);

    //箭头函数的简写
    //省略小括号， 当形参有且只有一个的时候 （）
    // let add=n=>{
    // return n+n;
    // };
    // console.log(add(9));
    //省略花括号，当代码题只有一条语句的时候 此时return必须省略
    // let pow=n=> n*n; 
    // console.log(9);




    //需求 点击div 2s后变成粉色
    //  let ad=document.getElementById('ad');
    //  ad.addEventListener("click",function(){
    //   setTimeout(()=>{ //es6函数方式 箭头函数this是静态的指向声明时所在作用域下this的值 ad下this的值
    //或者在外部保存this的值
    // let _this=this; //此时这样是保存this的值
    // console.log(this); 报错 this指向window
    //   _this.style.background="pink"; //报错指向window let应该局部
    //   },2000)
    //  })


    //声明一个数组 返回偶数的元素
    //   let ad=document.getElementById("ad");
    //    const arr=[1,3,36,53,4,5];
    //        const result=arr.filter(function(item){
    //            if(item%2===0){
    //                return true;
    //            }else{
    //                return false
    //            }
    //        });
    //   console.log(result);
    //语法2适合于this无关的回调 定时器，数组的方法返回
    //不适合不代表不能 this有关的回调 例如事件回调，对象的方法 ，this没有自己的对象要引用外层函数的对象
    //  const result=arr.filter(item=>item%2===0);
    //  console.log(result);
    //对象的方法报错
    //  {
    //  name:'sh',
    //  getName()=>{
    //  this.name;
    //  }
    //  }

    //es6允许给函数参数赋值初始值
    //形参初始值，具有默认值的参数，一般位置要靠后。

    //  function add(a,b,c){
    //   return a+b+c;
    //   }
    //   let result=add(1,2,3); //如果有一个值没传递是undifined最后一个数
    //   console.log(result);
    //   2、 与解构赋值集合
    // function connect(){         //connect({host="1234",username,password,port})这样写
    //  let host=options.host;
    //  let username=options.username  //此时会发现options写重复了可以这样写

    //此时改进后可以直接 console.log(host);
    // }
    // connect({
    //如果在形参中串了默认值则默认值  如果没有默认值 在coneect中有赋值 使用下边的
    // host:'sdsd',
    // username:'dsdsdsdsdfff',
    // password:'dddffggc',
    // })

    //    es6引入rest参数，用于获取函数的实参，用来代替arguments
    //  es5获取实参的方式
    //  function date(){
    //  console.log(arguments);
    //  }
    //  date("dd","ddd","dddd"); //对象arguments  
    //rest 参数
    //  function date(...args){ //...args是默认写法
    //      console.log(args);

    //  }
    //  date('dd',"ffff"); //数组
    //   rest参数必须要放到参数的最后
    // function fn(a,b,...args){
    // console.log(a);
    // console.log(b);
    // console.log(args);
    // }
    // fn(1,2,3,4,5,6);  //3456给了args  如果args写成 a,...args,b会报错 因为args代表了前边的全部 b就没了
    //...拓展运算符能将数组转换为逗号分割的参数序列
    //声明一个数组
    // const tfboys=['sdsdsd','sdsdsdffffff','ddsa']; // 转换成这样子 =>'sdsdsd','sdsdsdfffff' ...
    //声明一个函数 
    //    function chuwan(){
    // console.log(arguments);
    //    }
    //    chuwan(tfboys); // 此时就一个数组
    //    chuwan(...tfboys); //此时就三个数组 相当于 chuwan("sdsdsd",'sdsdsdfff','ddsa')


    //  数组的合并 
    //  const kuaizi=['wangtai','xiaod'];
    //  const fengh=['dd','lhua'];
    //  const zuixuan= kuaizi.concat(zuixuan); //数组的合并 es5的方法 但是下边提供了新的方法
    //  console.log(zuixuan);
    //  const zuixuan=[...kuaizi,...fengh]; //数组的合并es6都是可以的
    //  console.log(zuixuan);

    // 2， 数组的克隆
    // const sanzhihua=['e','g','m'];
    // const san=[...sanzhihua];
    // console.log(san); //数组克隆 将san 克隆到 sanzhihua

    //3.将伪数组转换为真正的数组;
    //  const divs=document.querySelectorAll('div');
    // 没用...拓展之前只有有很多其他属性
    //  const divArr=[...divs]; //转化后只剩数组
    //  console.log(divArr); //arguments 也可以转换


    //symbol 基本使用 第七种数据类型 ， string，bool,number NAN, null，undefined symbol
    //创建symbol
    //  let s=Symbol();//此时返回一个symbol的值
    //   let s2=Symbol('ddd');
    //   let s3=Symbol("ddd");  
    //  console.log(s,typeof s);
    //  console.log(s2);    //此时会显示一个symbol的返回值  symbol(ddd);
    //  console.log(s2===s3);  //此时是不一样的因为只是名字一样 底层的内存值不同     

    //symbol.for创建
    //    let s4=symbol.for("shan");
    //    let s5=symbol.for('shan');
    //    上下相等。

    //symbol的值是唯一的 用来解决命名冲突问题， 不能与其他数据进行运算， 不能使用for in 循环但是可以使用 reflect.ownkeyds 来获取对象所有的键名。
    //usonb JS数据类型  undefined,string, object , number,boolean

    //向对象中添加方法  up down
    //   let game={

    //   }
    //声明一个对象
    //    let methods={
    //        up:Symbol(),
    //        down:Symbol()
    //    };
    //    game[methods.up]=function(){
    //        console.log("我可以改变形状");
    //    }
    //    game[methods.down]=function(){
    //        console.log("我可以快速下降");
    //    }
    //    console.log(game);


    // 方法二:
    // let youxi={
    //      name:"狼人杀",
    //      [Symbol('say')]:function(){
    //          console.log('d');
    //      },
    //      [Symbol('zibao')]:function(){
    //          console.log('我可以自保');
    //      }
    // }
    // console.log(youxi);

    //    symbol.属性值

    //迭代器
    //声明一个数组
    //  let xiyou=['唐僧','孙悟空','猪八戒','沙僧'];

    //   for(let v of xiyou){
    //       console.log(v);
    //   }
    //for in 循环保存的是数组索引  for v 保存的是值 
    //工作原理 首先创建一个指针对象 指向当前数据结构的起始位置
    // 第一次调用对象的next方法 指针自动指向数据结构的第一个成员
    //接下来不断调用next方法 指针一直往后移动，直到只想最后一个成员，每次调用返回一个包含value和done的属性对象、 
    //要自定义遍历数据的时候要想到迭代器

    //自定义遍历

    //banji.stus.foreach() 可以但是不符合面向对象的思想。
    //生成器其实就是一个特殊的函数
    //异步编程 春回调函数 
    //函数代码的分隔符
    //   function *gen(){
    //       //console.log(111);
    //       yield '一直没有耳朵';
    //       console.log(222);
    //     //   yield '一只没有俄日';
    //     //   console.log(333);
    //     //   yield 'ddd';
    //   }
    //   let iterator =gen();
    //   console.log(iterator.next()); //yield是用来分割的此时 每个就相当于代码块  要分别调用才执行

    // // 遍历
    //   for(let v of gen()){
    //       console.log(v);
    //   }

    //生成器函数参数
    //    function * gen(arg){
    //        console.log(arg);
    //        let one= yield 111;
    //        console.log(one);
    //        yield 222;
    //        yield 333;
    //    }

    //    //执行获取迭代器对象
    //     let iterator =gen('aaa');
    //     //next方法可以传入实参
    //     console.log(iterator.next());
    //     console.log(iterator.next('bbb'));

    //异步编程  文件操作  网络操作(ajax ,request) 数据库操作
    // 1s后控制台输出111 2s 222 3s 333
    //回调地狱 一层套一层 不方便维护
    // setTimeout(()=>{
    //     console.log(111);
    //     setTimeout(()=>{
    //         console.log(222);
    //     },3000)
    // },2000)


    //生成器函数 实例

    //   function one(){
    //       setTimeout(()=>{
    //           console.log(111);
    //           d.next();
    //       },1000)
    //   }
    //   function two(){
    //       setTimeout(()=>{
    //           console.log(222);
    //           d.next();
    //       },2000)
    //   }
    //   function three(){
    //       setTimeout(()=>{
    //           console.log(333);
    //           d.next();
    //       },3000)
    //   }
    //   //生成器函数 *
    //    function *gen(){
    //        yield one ();
    //        yield two();
    //        yield three();
    //    }
    //     let d=gen();
    //     d.next();


    //模拟获取 用户数据 订单数据 商品数据
    //异步
    // function getuser(){
    //     setTimeout(()=>{
    //         let data='用户数据'
    //         s.next(data);
    //     },1000)
    // }
    //  function getorders(){
    //      setTimeout(()=>{
    //          let data='订d单数据'
    //          s.next(data);
    //      },1000)
    //  }
    //  function goods(){
    //      setTimeout(()=>{
    //          let data='商品数据'
    //          s.next(data);
    //      },1000)
    //  }
    // function  *gen(){
    //  let users=yield getuser()
    //  console.log(users);
    //  let orders=yield getorders();
    //  console.log(orders);
    //  let goos=yield goods();
    //  console.log(goos);
    // }
    // let s=gen();
    // s.next();


    //promise 是es6引入异步编程的新解决方案 语法上是一个构造函数，用来封装异步操作并可以获取其成功或者失败的结果
    // promise 构造函数 promise(excutor){}
    // promise.prototype.then 方法
    // promise.prototype.catch 方法 

    //实例化 promise 对象
    //    const p=new Promise(function(resolve,reject){
    //        setTimeout(function(){
    //         //    let data='数据库中国数据';
    //         //    resolve(data);  //resolve叫成功 reject失败
    //             let err='失败';
    //             reject(err);
    //        },1000)
    //    });
    //    //调用promise中then方法 
    //    p.then(function(value){
    //           console.log(value);
    //    },function(reason){
    //        console.error(reason);
    //         //成功形参叫value  失败叫reson  上边两个参数写啥都可以
    //    })
    // 引入fs模块
    // const fs=require('fs');  //模块是nodejs的
    // //调用方法
    // fs.readFile('1.md',(err,data)=>{
    //      //如果失败报错 
    //      if (err) throw err;
    //        //成功输出内容
    //         console.log(data.toString());
    // })

    //使用promise封装
    //  const p=new Promise(function(sus,rej){
    //      fs.readFile("1.md",(err,data)=>{
    //           if(err) rej(err);
    //            //如果成功
    //         sus(data);
    //      })
    //  })
    //  p.then(function(value){
    //      console.log(value);
    //  },function(reason){
    //      console.log("shibai");
    //  })

    //promise 封装ajax
    //接口地址 https://api.apiopen.top/getJoke
    // const p=new Promise((resolve,reject)=>{


    //创建对象
    //         const xhr=new XMLHttpRequest();
    //         //初始化
    //          xhr.open("GET","https://api.apiopen.top/getJoke");
    //           //发送
    //           xhr.send();
    //          //绑定事件
    //          xhr.onreadystatechange=function(){
    //              if(xhr.readyState===4){
    //                   if(xhr.status>=200&&xhr.status<300){
    //                        //chenggong
    //                       console.log(xhr.response);
    //                   }else{
    //                       //shibai
    //                        console.err(status);
    //                   }
    //              }
    //          }
    //         })
    //  //指定会调
    //    p.then(function(value){
    //        console.log(value);
    //    },function(reason){
    //     cosnole.error(reason);
    //    }

    //    )

    //创建promise对象
    //   const p=new Promise((resolve,reject)=>{
    //       setTimeout(()=>{
    //           resolve('用户数据');
    //       },1000)
    //   });
    //    //调用then方法 then方法返回的结果是promise对对象，对象状态由函数执行结果决定。
    //    //如果函数中放回的结果是 非promise类型的属性， 状态为成功，返回值为对象的成功值
    //  const result= p.then(value=>{console.log(value)
    // ;
    //    // 不是promise对象
    //  //return 'i love y';
    //   //是 promise 对象
    //    return new Promise((resolve,reject)=>{
    //        reject('error');
    //    });
    // },reason=>{console.warn(reason)});
    //  console.log(result);
    //   //链式调用
    //    p.then(value=>{

    //    }).then(value=>{

    //    });

    //  Promise读取多个文件 
    // 引入fs模块  //实际不会有这样嵌套
    //   const fs=require("fs");
    //    fs.readFile('1.md',(err,data1)=>{
    //         fs.readFile('1.md',(err,data2)=>{
    //              let result=data1+data2;
    //              console.log(result);
    //         })
    //    }) //回调地狱 会一直往下陷  代码
    //promise实现
    // const p=new Promise((resolve,reject)=>{
    //     fs.readFile("1.md",(err,data)=>{
    //         resolve(data);
    //     });
    // })
    // p.then(value=>{ //异步
    //      return new Promise((resolve,reject)=>{
    //         fs.readFile("2.md",(err,data)=>{
    //             resolve([value,data]);
    //     });
    //      })
    //     // console.log(value.toString());
    // }).then(value=>{ //运行完上边后 下一步 继续异步
    //     return new Promise((resolve,reject)=>{
    //         fs.readFile("3.md",(err,data)=>{
    //           value.push(data);
    //           resolve(data);
    //     });
    //      })
    // }).then(value=>{ //运行完上边后 下一步 继续异步
    //     return new Promise((resolve,reject)=>{
    //         fs.readFile("4.md",(err,data)=>{
    //           value.push(data);
    //           resolve(data);
    //     });
    //      })
    // }).then(value=>{
    //     console.log(value.join('\r\n')) //拼接 \R\N
    // })
     
      //promise

        // const p=new Promise((resolve,reject)=>{
        //     setTimeout(()=>{
        //         reject("err");
        //     },1000)
        // });
        // p.then(function(value){},function(reason){console.log(reason)})
        //  //报错
        // p.catch(function(reason){
        //     console.warn(reason);
        // })


        //es6中提供了 新的数据结构 set(集合)
        //   属性 ：size返回集合的元素个数
        //  add 增加一个新元素 返回当前集合
        // delete 删除元素 返回boolean值
        // has 检测集合中是否包含某个元素，返回bool值

              //声明一个set
            //    let s=new Set();
            //    let s2=new Set(['d','f']);
            //    s2.add('fff');
            //    console.log(s2);
            
            //数组去重  
            //  let arr=[1,2,3,4,5,6,1,2,3,89];
            // let result=[...new Set(arr)];
            // console.log(result);
            //交集 
            // let arr2=[4,5,6,12,2,3,1];
            // let result=[...new Set(arr)].filter(item=>{
            //     let s2=new Set(arr2); //4,5,6
            //     if(s2.has(item)){
            //         return true;
            //     }else{
            //         return false;
            //     }
            // })
            // console.log(result);
             //可这样写 let  result=[...new Set(arr)].filter(item=>new Set(arr2).has(item));


 //并集
//    let union =[...new Set([...arr,...arr2])];
//    console.log(union);
//差集
//    let diff=[...new Set(arr)].filter(item=>!(new Set(arr2).has(item)));
//    console.log(diff);
  //MAP
   // map数据结构 它类似与对象 也是键值对的集合 但是键的范围不限于字符串， 各种类型的值包括对象 都可以作为键 map也实现了iterator接口  所以可以使用拓展运算符和for of 锦星便利
// size 返回map元素个数
// set 增加一个新元素 返回当前map
// get 返回键值对名对象的键值
// has 检测map中是否包含某个元素 返回boolean值
// clear 清空集合 返回undefined
                        // 声明
                //     let m=new Map()
                //   m.set("d");
                //   m.set('change',function(){
                //       console.log('fff');
                //   });
                //   let key='sdsd';
                //   m.set(key,['beijing','df']);
                //   console.log(m);


 //class类
//   function phone(brand,price){
//        this.brand=brand;
//        this.price=price;
//   }
//    //添加方法
//   phone.prototype.call=function(){
//       console.log('dsds');
//   }

//    //实例化对象
//   let huawei=new phone('dd',433);
//   huawei.call();
//   console.log(huawei); 
  //手写一个class类 
//   class phone{
//       //构造方法 名字不能修改 必须叫这个
//        constructor(brand,price){ //里面其实是个执行器
//         this.brand=brand;
//         this.price=price;
//        }
//        //必须使用该语法不能使用 es5对象的完整形式
//           //call:function(){}
//        call(){
//       console.log('dddddddff');
//        }
//   }
//   let onePlus=new phone("1+",999);
//   onePlus.call();
//   console.log(onePlus);
 

 //类的静态成员
//   function Phone(){

//   }
//   Phone.name='手机';
//   Phone.change=function(){
//   console.log('dd');
//   }
//   Phone.prototype.size='5.5';
//   //实例化对象
//   let nd=new Phone();
//   console.log(nd.name);
//   console.log(nd.size);
//   nd.change(); //实例对象是实例对象 和函数对象不同 但是和原型对象是相通的 所以无法调用


  //静态属性 static 通过 类名.方法 访问
//  class Phone{
//       static name='手机';
//       static change(){
//           console.log('ddd');
//       }
//  }
//  let onf=new Phone();
//  console.log(on.name);
//  console.log(Phone.name);

 //构造函数继承
//    function phone(brand,price){
//         this.brand=brand;
//         this.price=price;
//    }
//     phone.prototype.call=function(){
//         console.log("dsd");
//     }
//     function smartphone(brand,price,color,size){
//         phone.call(this,brand,price);
//         this.color=color;
//         this.size=size;
//     }
//      //设置子级构造函数的原型
//       smartphone.prototype=new phone;
//       smartphone.prototype.constructor=smartphone; //加不加没影响
//         //声明子类的方法
//          smartphone.prototype.photo=function(){
//              console.log("wdddff");
//          }
//          smartphone.prototype.play=function(){
//              console.log("play");
//          }
//          const chuizi=new smartphone("chuizi",'2499','5.5inch');
//          console.log(chuizi); 
   
     //类继承
    //   class phone{
    //        //构造方法
    //       constructor(brand,price){
    //           this.brand=brand;
    //           this.price=price;
    //       }
    //        //父类成员属性
    //        call(){
    //            console.log("我可以")
    //        }
    //   }

    //    class smartphone extends phone{
    //        //构造方法
    //         constructor(brand,price,color,size){
    //              super(brand,price); //phone.call(this.brand,price)
    //             this.color=color;
    //             this.size=size;
    //             }
    //              photo(){
    //                  console.log("sadasasd");
    //              }
    //              play(){
    //                  console.log("wan");
    //              }
    //                call(){
    //                    console.log("asjdajdjasd"); //子类是不能调用父类的同名方法的
    //                }
    //    }
    //     //实例化
    //       const xiami=new smartphone("xiaomi",799,"heise","4.7inch");
    //       console.log(xiami); //brand / price/ color /size
    //    xiami.call(); //三个方法都没问题  子类无法直接调用父类的同名call方法
    //    xiami.photo();
    //    xiami.play();







</script>
